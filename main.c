#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/garbage.h"
#include "images/cat.h"
#include "images/basket.h"
#include "images/fish.h"
#include "images/heart.h"
#include "images/bad.h"
#include "images/win.h"
#include "images/start.h"

#define BG BLACK
#define FG WHITE

// player dimensions
#define playerW 30
#define playerH 30

// basket dimensions
#define basketW 25
#define basketH 25

// fish dimensions
#define fishW 15
#define fishH 15

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.

//initalizes the game

void game_init(MainState *game)
{
  drawFullScreenImageDMA(start); 
  // resets the game
  game->status = START;
  game->score = 0;
  game->lives = 3;

  // reset the player at top 
  box_rand_player(&game->player.boundary, playerW, playerH);
  game->player.velocity.y = 1; 

  // creating items
  for (int i = 0; i < MAX_ITEMS; i++)
  {
    box_rand_item(&game->objects[i].boundary, fishW, fishH);
    game->objects[i].type = (randint(0, 100) >= 50) ? FISH : HEART;
    game->objects[i].active = 1;
  }

  //creating basket
  box_center_bottom(&game->basket.boundary, basketW, basketH);
  game->basket.velocity.y = 0;
  game->basket.velocity.x = 2;
  game->currentButtons = BUTTONS;
  game->previousButtons = BUTTONS;
}

void game_play(MainState *game)
{
  // clearing old objects
  box_fill(&game->player.boundary, BG);
  box_fill(&game->basket.boundary, BG);

  // moving the player
  box_vmove(&game->player.boundary, game->player.velocity);

  // moving the basket
  box_vmove(&game->basket.boundary, game->basket.velocity); 
  
  // Checking player collision with basket 
  if (box_intersects(&game->player.boundary, &game->basket.boundary))
  {
    game->score++; 
    box_rand_player(&game->player.boundary, game->player.boundary.w, game->player.boundary.h);
    for (int i = 0; i < MAX_ITEMS; i++) {
      if (!game->objects[i].active) {
        game->objects[i].active = 1; 
        game->objects[i].type = (randint(0, 5) < game->lives) ? FISH : HEART;
      }
    }
  }

  // Checking if player went off screen boundary
  if (box_bottom_crossed(&game->player.boundary))
  {
    game->lives--;
    box_rand_player(&game->player.boundary, game->player.boundary.w, game->player.boundary.h);
    for (int i = 0; i < MAX_ITEMS; i++) {
      if (!game->objects[i].active) {
          game->objects[i].active = 1; 
         game->objects[i].type = (randint(0, 5) < game->lives) ? FISH : HEART;
      }
    }
  }
  
  if(game->lives <= 0) {
      if (game->score < 10) {
        game->status = LOSE;
        drawFullScreenImageDMA(bad);
      } else {
        game->status = WIN; 
        drawFullScreenImageDMA(win); 
      }
      return; 
    }

    if (box_right_crossed(&game->basket.boundary))
    {
      game->basket.velocity.x *= -1;
    }
    if (box_left_crossed(&game->basket.boundary))
    {
      game->basket.velocity.x *= -1;
    }
    if (KEY_DOWN(BUTTON_DOWN, game->currentButtons))
    {
      game->player.boundary.y++;
    }
    if (KEY_DOWN(BUTTON_LEFT, game->currentButtons))
    {
      game->player.boundary.x--;
    }
    if (KEY_DOWN(BUTTON_RIGHT, game->currentButtons))
    {
      game->player.boundary.x++;
    }

    for (int i = 0; i < MAX_ITEMS; i++)
    {
      if (game->objects[i].active)
      {
        box_fill(&game->objects[i].boundary, BG);

        if (game->objects[i].type == FISH)
        {
          box_image(&game->objects[i].boundary, fish);
        }
        else if (game->objects[i].type == HEART)
        {
          box_image(&game->objects[i].boundary, heart);
        }

        // collision with item 
        if (box_intersects(&game->objects[i].boundary, &game->player.boundary))
        {
          if (game->objects[i].type == FISH)
          {
            game->score+=1; 
          }
          else if (game->objects[i].type == HEART)
          {
            game->lives++; 
          } 
          box_fill(&game->objects[i].boundary, BG);
          game->objects[i].active = 0;

          // reseting position of items
          box_rand_item(&game->objects[i].boundary, fishW, fishH);
        }
      }
    }

    box_image(&game->player.boundary, cat);
    box_image(&game->basket.boundary, basket);
  }

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  MainState game;
  fillScreenDMA(BG);
  game_init(&game);

  char scoreMsg[16];
  char livesMsg[16];

  while (1) {
    game.currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    waitForVBlank();

    if (KEY_JUST_PRESSED(BUTTON_SELECT, game.currentButtons, game.previousButtons))
    {
      game_init(&game); // restart
    }

    switch (game.status) 
    {

    case START:
      if (KEY_JUST_PRESSED(BUTTON_START, game.currentButtons, game.previousButtons))
      {
        game.status = PLAY;
        fillScreenDMA(BLACK);  
      }
      break;

    case PLAY:
      snprintf(scoreMsg, 16, "Score: %d", game.score);
      snprintf(livesMsg, 16, "lives: %d", game.lives);
      drawRectDMA(0, 170, 80, 20, BG);
      drawRectDMA(HEIGHT - 10,200, 30, 30, BG);
      drawString(10, 170, scoreMsg, FG);
      //drawRectDMA(0,170,game.lives*10,10, MAGENTA); 
      drawString(0, 170, livesMsg, FG);

      game_play(&game);

      break;

    case WIN:
      drawString(120, 60, scoreMsg, WHITE);
      drawString(130, 60, "BACKSPACE to play again", WHITE);
      break;

    case LOSE:
      drawString(120, 60, scoreMsg, BLACK);
      drawString(130, 60, "BACKSPACE to play again", BLACK);
      break;
    }

    game.previousButtons = game.currentButtons; // Store the current state of the buttons
  }

  return 0;
}
